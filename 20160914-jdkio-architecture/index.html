<!DOCTYPE html>
<html>
  <head>
    <title>Event sourcing at Tradeshift</title>
    <meta charset="utf-8">
    <style>
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body { font-family: 'Droid Serif'; }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: normal;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }
      .small { font-size: 75%; }
    </style>
  </head>
  <body>
    <textarea id="source">

class: center, middle

# Event sourcing at scale



Jan Ypma

jyp@tradeshift.com

---

# Agenda

- A bit of Tradeshift history
- Typical sources of failures
- Introduction to actors and akka
- Event sourcing
- Example use case: collaboration

---

# Tradeshift in 2011

TODO picture

- Two major software components
  - _the frontend_
  - _the backend_
- &lt;10 developers

--

# Tradeshift in 2016

TODO picture

- 30 deployed components
- 150 developers
- 250.000 LoC in _the backend_

---

# Scaling of Tradeshift's systems

- Moore's law applies to AWS 
- Single point of _not quite failing often enough_


- 2016 directive:

    _All new components must be clustered_

- Yeah, what about the 30-ish existing ones?
  - New architecture is needed
  
---

# Scaling of Tradehift's development process

- 2011: _"We're a Java shop"_
--

- 2016: Not really, at least not anymore
  - Groovy and grails
  - Python, go, ruby for infrastructure
  - Crazy javascript people
  - Scala 
- But still, mostly Java  
  
- Empower teams to pick their own language and frameworks

---

# Typical sources of failures

- TODO picture here Browser -> Proxy -> Frontend -> Workflow -> App-Service -> Backend -> Database

- We're down!
  - We overloaded the database
  - which caused the backend to respond slowly
  - which caused the frontend to respond slowly
  - which caused our users' web browsers to respond slowly
  - which caused our users to reload their page
  - `GOTO 10`
[note: lock up threads]


- Enter the buzzwords
  - Let it crash [2003, Amstrong]
  - Micro-services [2005, Rodgers]
  - Self-contained systems [2015]

---

# Design rules

- TODO picture here: vertical stack of a service, stressing async comms between services

- No syncronous outgoing calls while handling an incoming request
  - (except to our own databases)
  - All inter-service communication must be asynchronous
- No single points of failure
  - System must be clustered
- Design must trivially scale to 10x expected load

---

# Event sourcing

- TODO picture here: aggregates with events, e.g. users with address and password changes, including event stream

- System considers an *append-only* journal of *Events* the only source of truth
- *Aggregate* is one unit of information to which (and only which) an event atomically applies
- Events only have a guaranteed order within an aggregate (not across aggregates)
- All information that spans >1 aggregate is materialized using *event listeners*
- Traditionally only applied inside a system 
  - Synchronous APIs only ("_get customer history_")
- Why not expose event stream itself?
  - Eventual consistency
  - Latency implications
  - Security implications

---

# The actor model

- **Actor** is an entity that responds only to messages by
  - sending messages to other actors
  - creating other, child, actors
  - adjusting its behaviour

- *Akka* is a toolkit for writing actors in Java
  - Actor is a normal Java class that extends `UntypedActor` or `AbstractActor`

- **Message** is an immutable, serializable, Java class

- Parent actor is the _supervisor_ of its child actors. On child actor failure, parent decides what to do:
  - Restart child
  - Stop child
  - Escalate
  
---

# Actor ping pong 

```java
public class PongActor extends UntypedActor {

    public void onReceive(Object message) {
        if (message instanceof String) {
            log.info("In PongActor - received message: {}", message);
            getSender().tell("pong", getSelf());
        } 
    }
}
```

---

# Actor ping pong 

```java
public class PingActor extends AbstractActor {
    private int counter = 0;
    private ActorRef pongActor = getContext().actorOf(
        Props.create(PongActor.class), "pongActor");
    {
        receive(ReceiveBuilder
            .match(Initialize.class, msg -> {
                log.info("In PingActor - starting ping-pong");
                pongActor.tell("ping", getSelf());
            })
            .match(String.class, msg -> {
                log.info("In PingActor - received message: {}", message);
                counter += 1;
                if (counter == 3) {
                    getContext().system().shutdown();
                } else {
                    getSender().tell("ping", getSelf());
                }
            })
            .build());
    }
}
```

---

# Actor ping ping
```java
public static void main() {
    
}
```

--- 

# Akka remoting



---

# Akka persistence

- Framework to do event sourcing using actors
- Persistence plugins for levelDB, cassandra, kafka, ...
- Each `PersistentActor` has a `String` identifier, under which events are stored

```java
public class ChatActor extends AbstractPersistentActor {
  private final List<String> messages = new ArrayList<>();
  
  @Override public String persistenceId() { return "chat-conversation-1"; }
  
  @Override public void receiveRecover(Object msg) {
    if (msg instanceof String) { messages.add((String)msg); }
  }
  
  @Override public void receiveCommand(Object msg) {
    if (msg.equals("/list")) {
      sender().tell(new ArrayList<>(messages));
    } else if (msg instanceof String) { 
      persist(msg, evt -> messages.add((String)msg));
    } 
  }
}
```

---

# Akka cluster sharding


---

# Putting it all together

- In production: collaboration
- In development: documents, FTP

- Introduce ts-reaktive

---

# Use case: collaboration

    </textarea>
    <script src="remark-latest.min.js"></script>
    <script>
      var slideshow = remark.create({
          highlightLanguage: "java",
          highlightLines: true
      });
    </script>
</html>
